# Stubs for bayesian_hmm.hdphmm (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import numpy as np
from .chain import Chain
from .utils import dirichlet_process_generator, label_generator, shrink_probabilities
from typing import Any, Callable, Dict, Generator, Iterable, List, Optional, Union

Numeric = Union[int, float]
DictStrNum = Dict[Optional[str], Numeric]
InitDict = DictStrNum
DictStrDictStrNum = Dict[Optional[str], DictStrNum]
NestedInitDict = DictStrDictStrNum

class HDPHMM:
    chains: Any = ...
    sticky: Any = ...
    priors: Any = ...
    hyperparameters: Any = ...
    n_initial: Any
    n_emission: Any
    n_transition: Any
    p_initial: Any
    p_emission: Any
    p_transition: Any
    auxiliary_transition_variables: Any
    beta_transition: Any
    beta_emission: Any
    emissions: Any = ...
    states: Any = ...
    def __init__(self, emission_sequences: Iterable[List[Optional[str]]], emissions: Any=..., sticky: bool=..., priors: Dict[str, Callable[[], Any]]=...) -> None: ...
    @property
    def initialised(self) -> bool: ...
    @initialised.setter
    def initialised(self, value: Any) -> None: ...
    @property
    def c(self) -> int: ...
    @property
    def k(self) -> int: ...
    @property
    def n(self) -> int: ...
    def tabulate(self) -> np.array: ...
    def state_generator(self, eps: Numeric=...) -> Generator[str, None, None]: ...
    def initialise(self, k: int=...) -> None: ...
    def update_states(self) -> None: ...
    def resample_beta_transition(self, ncores: int = ..., auxiliary_resample_type: str = ..., use_approximation: bool = ..., eps: float = ...) -> None: ...
    def calculate_beta_transition_loglikelihood(self): ...
    def resample_beta_emission(self, eps: float = ...) -> None: ...
    def calculate_beta_emission_loglikelihood(self): ...
    def resample_p_initial(self, eps: float = ...) -> None: ...
    def calculate_p_initial_loglikelihood(self): ...
    def resample_p_transition(self, eps: float = ...) -> None: ...
    def calculate_p_transition_loglikelihood(self): ...
    def resample_p_emission(self, eps: float = ...) -> None: ...
    def calculate_p_emission_loglikelihood(self): ...
    def print_fit_parameters(self): ...
    def print_probabilities(self) -> None: ...
    def calculate_chain_loglikelihood(self): ...
    def calculate_loglikelihood(self): ...
    def resample_chains(self, ncores: int = ...) -> None: ...
    def maximise_hyperparameters(self) -> None: ...
    def resample_hyperparameters(self) -> None: ...
    def mcmc(self, n: int = ..., burn_in: int = ..., save_every: int = ..., ncores: int = ..., verbose: bool = ...): ...
